[{"content":"Before diving into the \u0026ldquo;why,\u0026rdquo; let’s first understand the problem SQL Components aims to solve.\nConsider a simple Java application that connects to a relational database like PostgreSQL to create a movie store. The database schema looks like this:\nCREATE TABLE movie ( id smallserial PRIMARY KEY, title VARCHAR(80), directed_by VARCHAR(80) );\rNow, let\u0026rsquo;s add some movies:\nINSERT INTO movie (title, directed_by) VALUES (\u0026#39;Inception\u0026#39;, \u0026#39;Christopher Nolan\u0026#39;), (\u0026#39;The Dark Knight\u0026#39;, \u0026#39;Christopher Nolan\u0026#39;), (\u0026#39;Interstellar\u0026#39;, \u0026#39;Christopher Nolan\u0026#39;), (\u0026#39;Dunkirk\u0026#39;, \u0026#39;Christopher Nolan\u0026#39;), (\u0026#39;Pulp Fiction\u0026#39;, \u0026#39;Quentin Tarantino\u0026#39;), (\u0026#39;The Matrix\u0026#39;, \u0026#39;Lana Wachowski\u0026#39;), (\u0026#39;Fight Club\u0026#39;, \u0026#39;David Fincher\u0026#39;), (\u0026#39;The Social Network\u0026#39;, \u0026#39;David Fincher\u0026#39;);\rSuppose you want to list the movies directed by Christopher Nolan. As a Java developer, your responsibilities include:\nManaging database connections Creating model or DTO classes Implementing Data Access Objects (DAO) Over the years, various Java frameworks have addressed these challenges in different ways. In the following sections, we’ll explore how these frameworks approach the problem and how SQL Components provides a unique solution.\n","date":"0001-01-01","id":0,"permalink":"/docs/why/","summary":"\u003cp\u003eBefore diving into the \u0026ldquo;why,\u0026rdquo; let’s first understand the problem SQL Components aims to solve.\u003c/p\u003e\n\u003cp\u003eConsider a simple Java application that connects to a relational database like PostgreSQL to create a movie store. The database schema looks like this:\u003c/p\u003e","tags":[],"title":"Why SQL Components"},{"content":"SQL Builders are tools designed to simplify database interaction by abstracting away complex SQL queries and connection management. They help developers focus on writing business logic rather than managing database connections and handling raw SQL queries. Popular SQL Builders like Spring JDBC and QueryDSL allow developers to construct SQL queries programmatically, making code more readable and maintainable.\nOut of the three main responsibilities—connection management, model/DTO creation, and DAO implementation—SQL Builders primarily remove the burden of connection management from developers.\nFor example, when using Spring JDBC Client, developers still need to create:\nModel classes Data Access Objects (DAO) using JDBC Clients RowMappers to map database results to Java objects Here’s a sample of how this works with Spring JDBC Client:\n// Model class public class Movie { private Long id; private String title; private String directedBy; // Getters and Setters } // DAO using Spring JDBC public class MovieRepository { private JdbcTemplate jdbcTemplate; public MovieRepository(JdbcTemplate jdbcTemplate) { this.jdbcTemplate = jdbcTemplate; } public List\u0026lt;Movie\u0026gt; findMoviesByDirector(String director) { String sql = \u0026#34;SELECT * FROM movie WHERE directed_by = ?\u0026#34;; return jdbcTemplate.query(sql, new Object[]{director}, new RowMapper\u0026lt;Movie\u0026gt;() { public Movie mapRow(ResultSet rs, int rowNum) throws SQLException { Movie movie = new Movie(); movie.setId(rs.getLong(\u0026#34;id\u0026#34;)); movie.setTitle(rs.getString(\u0026#34;title\u0026#34;)); movie.setDirectedBy(rs.getString(\u0026#34;directed_by\u0026#34;)); return movie; } }); } }\rSQL Components: A Type-Safe Alternative While SQL Builders abstract connection management, SQL Components offers additional benefits by providing a type-safe API and eliminating the need for manual code related to models, DAOs, and RowMappers. Here\u0026rsquo;s how you can achieve the same functionality using SQL Components:\nList\u0026lt;Movie\u0026gt; movies = DataManager.getManager().getMovieStore() .select(directedBy().eq(\u0026#34;Christopher Nolan\u0026#34;)) .returning();\rKey Differences:\nAutomatic Code Generation: Models, DAOs, and RowMappers are generated automatically. Type-Safe API: Compile-time error checking ensures safety and reduces runtime issues. Framework Independence: No need for external frameworks like Spring; it’s pure Java code that can be easily integrated into any Java application. ","date":"0001-01-01","id":1,"permalink":"/docs/why/sql-builders/","summary":"\u003cp\u003e\u003cstrong\u003eSQL Builders\u003c/strong\u003e are tools designed to simplify database interaction by abstracting away complex SQL queries and connection management. They help developers focus on writing business logic rather than managing database connections and handling raw SQL queries. Popular SQL Builders like \u003cstrong\u003eSpring JDBC\u003c/strong\u003e and \u003cstrong\u003eQueryDSL\u003c/strong\u003e allow developers to construct SQL queries programmatically, making code more readable and maintainable.\u003c/p\u003e","tags":[],"title":"SQL Builders"},{"content":"Java Persistence API (JPA) is a well-known framework that abstracts most of the database interaction for Java applications by utilizing Object-Relational Mapping (ORM). JPA handles both connection management and DAO implementation, leaving the developer to focus on defining model classes and mapping them to database tables.\nWith JPA, developers only need to annotate their model classes with the appropriate mappings to the database schema:\n@Entity @Table(name = \u0026#34;movie\u0026#34;) public class Movie { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String title; @Column(name = \u0026#34;directed_by\u0026#34;) private String directedBy; // Getters and Setters }\rHere’s how you would use JPA to find movies by a specific director:\npublic class MovieRepository { @PersistenceContext private EntityManager entityManager; public List\u0026lt;Movie\u0026gt; findByDirector(String director) { String jpql = \u0026#34;SELECT m FROM Movie m WHERE m.directedBy = :director\u0026#34;; return entityManager.createQuery(jpql, Movie.class) .setParameter(\u0026#34;director\u0026#34;, director) .getResultList(); } }\rSQL Components: Flexibility Beyond ORM While JPA simplifies connection management and DAO implementation, SQL Components provides greater flexibility by allowing developers to go beyond simple table-to-entity mappings. With SQL Components, you can easily work with stored procedures, views, and other advanced database features that are often difficult to handle with standard ORM frameworks like JPA.\nHere’s what sets SQL Components apart:\nNo ORM Restrictions: SQL Components allows you to fully leverage relational databases without being restricted by table-entity mapping. You can work with stored procedures, views, and even complex queries effortlessly.\nNative Java Code Generation: Unlike JPA, which often relies on reflection APIs for dynamic entity handling, SQL Components generates pure Java code at compile-time, significantly boosting performance.\nType-Safe API: SQL Components ensures compile-time type checking, reducing runtime errors and offering more reliability.\nIn SQL Components, the same query to list movies directed by a particular director would look like this:\nList\u0026lt;Movie\u0026gt; movies = DataManager.getManager().getMovieStore() .select(directedBy().eq(\u0026#34;Christopher Nolan\u0026#34;)) .returning();\rKey Differences:\nFlexibility: SQL Components supports stored procedures, views, and advanced SQL features without ORM limitations. Performance: Native Java code generation without reflection improves API performance. Type Safety: Compile-time checks ensure code correctness and reduce runtime errors. ","date":"0001-01-01","id":2,"permalink":"/docs/why/jpa/","summary":"\u003cp\u003e\u003cstrong\u003eJava Persistence API (JPA)\u003c/strong\u003e is a well-known framework that abstracts most of the database interaction for Java applications by utilizing \u003cstrong\u003eObject-Relational Mapping (ORM)\u003c/strong\u003e. JPA handles both \u003cstrong\u003econnection management\u003c/strong\u003e and \u003cstrong\u003eDAO implementation\u003c/strong\u003e, leaving the developer to focus on defining \u003cstrong\u003emodel classes\u003c/strong\u003e and mapping them to database tables.\u003c/p\u003e","tags":[],"title":"JPA"},{"content":"JOOQ (Java Object Oriented Querying) is a powerful and widely-used Java framework for building type-safe SQL queries. JOOQ’s primary goal is to seamlessly integrate SQL into Java code by generating Java classes from a database schema, enabling developers to work with SQL in a type-safe, programmatic way.\nJOOQ provides many built-in features, such as:\nAutomatic query generation from the database schema Type-safe SQL queries Support for various SQL dialects (e.g., MySQL, PostgreSQL, Oracle) Integration with ORMs, like Hibernate Here’s an example of how you would use JOOQ to query a list of movies directed by a particular director:\n// JOOQ query example DSLContext context = DSL.using(connection, SQLDialect.POSTGRES); Result\u0026lt;Record\u0026gt; result = context.select() .from(MOVIE) .where(MOVIE.DIRECTED_BY.eq(\u0026#34;Christopher Nolan\u0026#34;)) .fetch(); List\u0026lt;Movie\u0026gt; movies = result.into(Movie.class);\rSQL Components: A Simpler, Flexible Alternative Here’s how the same functionality looks with SQL Components:\nList\u0026lt;Movie\u0026gt; movies = DataManager.getManager().getMovieStore() .select(directedBy().eq(\u0026#34;Christopher Nolan\u0026#34;)) .returning();\rWhile JOOQ is a mature framework with many features, SQL Components offers a more lightweight alternative, focusing on simplicity and flexibility without requiring a custom DSL. Here’s how SQL Components compares with JOOQ:\nFeature JOOQ SQL Components Query Execution Uses a custom DSL for query generation Leverages Java’s native library for SQL execution Complexity Requires knowledge of JOOQ DSL and database schema generation Simple and direct, using raw SQL queries Abstraction High level of abstraction with Java code representing SQL Minimal abstraction; code is direct and clear Dependency Size Larger library with various modules Lightweight and minimal dependencies Learning Curve Steeper learning curve due to JOOQ’s DSL Easy to learn with direct SQL and Java interaction Customization Highly customizable with support for multiple SQL dialects and ORMs Focused on simplicity without deep customizations Key Differences:\nNo Custom DSL: Unlike JOOQ, SQL Components doesn’t rely on a custom DSL but instead uses native Java code for execution, making it easier to integrate into any Java project. Support for All RDBMS: SQL Components offers support for a wide range of relational databases without requiring the developer to learn or manage multiple SQL dialects. Simplicity and Flexibility: SQL Components is designed to be simple to use and flexible, allowing you to write raw SQL queries and leverage database features like stored procedures and views without the complexity of an ORM. ","date":"0001-01-01","id":3,"permalink":"/docs/why/jooq/","summary":"\u003cp\u003e\u003cstrong\u003eJOOQ\u003c/strong\u003e (Java Object Oriented Querying) is a powerful and widely-used Java framework for building type-safe SQL queries. JOOQ’s primary goal is to seamlessly integrate SQL into Java code by generating Java classes from a database schema, enabling developers to work with SQL in a type-safe, programmatic way.\u003c/p\u003e","tags":[],"title":"Jooq"},{"content":"","date":"0001-01-01","id":4,"permalink":"/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"In order to generate the code at compiletime, SQLComponents has to be added as a build plugin ( under build \u0026gt; plugins in pom.xml ) along with the corresposing JDBC driver.\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.sqlcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;phase\u0026gt;generate-sources\u0026lt;/phase\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;generated-sources\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.postgresql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${postgresql.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/plugin\u0026gt;\r","date":"0001-01-01","id":5,"permalink":"/docs/getting-started/installation/","summary":"\u003cp\u003eIn order to generate the code at compiletime, SQLComponents has to be added as a build plugin ( under  \u003ccode\u003ebuild \u0026gt; plugins\u003c/code\u003e in \u003ccode\u003epom.xml\u003c/code\u003e ) along with the corresposing JDBC driver.\u003c/p\u003e","tags":[],"title":"Installation"},{"content":"We need configure SQLComponents to connect to the database instance. we should create a file named sql-components.yml as given below\n# Connection Details name: Sample url: \u0026#34;jdbc:postgresql://localhost:5432/sampledb\u0026#34; userName: \u0026#34;user\u0026#34; password: \u0026#34;password\u0026#34; schemaName: \u0026#34;sampledb\u0026#34; # Mapping Logic rootPackage: \u0026#34;com.example\u0026#34;\rAfter this, you can build the project with\nmvn clean package\ronce the build is suvvessful, you should see the generated code under target \u0026gt; generated-sources\n","date":"0001-01-01","id":6,"permalink":"/docs/getting-started/connection/","summary":"\u003cp\u003eWe need configure SQLComponents to connect to the database instance. we should create a file named \u003ccode\u003esql-components.yml\u003c/code\u003e as given below\u003c/p\u003e","tags":[],"title":"Connection"},{"content":"API Guide\n","date":"0001-01-01","id":7,"permalink":"/docs/guides/","summary":"\u003cp\u003eAPI Guide\u003c/p\u003e","tags":[],"title":"API Guide"},{"content":"SQL Components simplifies how your Java application interacts with relational databases by providing three core concepts:\nManager: Handles database connections and manages access to various database objects. Model: Represents the structure of database tables as simple Java objects (POJOs). Store: An interface that allows you to perform common database operations like Select, Insert, Update, and Delete on tables. ","date":"0001-01-01","id":8,"permalink":"/docs/guides/basics/","summary":"\u003cp\u003e\u003cstrong\u003eSQL Components\u003c/strong\u003e simplifies how your Java application interacts with relational databases by providing three core concepts:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eManager\u003c/strong\u003e: Handles database connections and manages access to various database objects.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eModel\u003c/strong\u003e: Represents the structure of database tables as simple Java objects (POJOs).\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eStore\u003c/strong\u003e: An interface that allows you to perform common database operations like \u003cstrong\u003eSelect\u003c/strong\u003e, \u003cstrong\u003eInsert\u003c/strong\u003e, \u003cstrong\u003eUpdate\u003c/strong\u003e, and \u003cstrong\u003eDelete\u003c/strong\u003e on tables.\u003c/li\u003e\n\u003c/ol\u003e","tags":[],"title":"Basics"},{"content":"Store will act as inteface for all the SQL operations againts tables.\nInsert Select Update Delete ","date":"0001-01-01","id":9,"permalink":"/docs/guides/table/","summary":"\u003cp\u003eStore will act as inteface for all the SQL operations againts tables.\u003c/p\u003e\n\u003ch2 id=\"insert\"\u003eInsert\u003c/h2\u003e\n\u003ch2 id=\"select\"\u003eSelect\u003c/h2\u003e\n\u003ch2 id=\"update\"\u003eUpdate\u003c/h2\u003e\n\u003ch2 id=\"delete\"\u003eDelete\u003c/h2\u003e","tags":[],"title":"Table"},{"content":" Stored Procedures are a powerful feature in relational databases that allow you to encapsulate SQL logic on the database side. A stored procedure is a precompiled set of one or more SQL statements that can perform complex operations like updates, inserts, and even condition handling. By moving logic into stored procedures, you can reduce the amount of database interaction from your application code, increase performance, and improve maintainability.\nHere’s an example of a stored procedure to transfer funds between two accounts:\nCREATE OR REPLACE PROCEDURE transfer( sender INT, receiver INT, amount DECIMAL ) LANGUAGE plpgsql AS $$ BEGIN -- Subtracting the amount from the sender\u0026#39;s account UPDATE accounts SET balance = balance - amount WHERE id = sender; -- Adding the amount to the receiver\u0026#39;s account UPDATE accounts SET balance = balance + amount WHERE id = receiver; COMMIT; END $$;\rThis stored procedure transfers an amount from one account to another by updating the balances of both accounts.\nTo call this stored procedure in SQL:\nCALL transfer(1, 2, 500);\rUsing SQL Components to Call Stored Procedures SQL Components makes it easy to call stored procedures directly from Java code without any need for complex mappings or additional libraries. Here’s how you can invoke the transfer stored procedure using DatabaseManager in SQL Components:\nDatabaseManager.getManager().transfer(1, 2, 500);\r","date":"0001-01-01","id":10,"permalink":"/docs/guides/stored-procedure/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eStored Procedures\u003c/strong\u003e are a powerful feature in relational databases that allow you to encapsulate SQL logic on the database side. A stored procedure is a precompiled set of one or more SQL statements that can perform complex operations like updates, inserts, and even condition handling. By moving logic into stored procedures, you can reduce the amount of database interaction from your application code, increase performance, and improve maintainability.\u003c/p\u003e","tags":[],"title":"Stored Procedure"},{"content":"Over the past two decades, the way we access relational databases from Java has evolved significantly. Starting with JDBC programming, we moved on to using SQL mappers and later adopted full-fledged ORM frameworks. However, modern architectures, such as cloud-native, microservices, and serverless, present new challenges that traditional persistence technologies may not fully address.\nIn this presentation, we will explore the history, theory, and technology behind the evolution of persistence technologies for Java applications. We will discuss the challenges posed by modern architectures and how cloud-native persistent technology can solve them. Join us to learn about the future of Java persistence and how you can prepare for it.\n","date":"2023-09-07","id":11,"permalink":"/blog/the-future-of-java-persistence/","summary":"we will explore the history, theory, and technology behind the evolution of persistence technologies for Java applications.","tags":[],"title":"The Future of Java Persistence"},{"content":"","date":"2023-09-07","id":12,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"0001-01-01","id":13,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":14,"permalink":"/","summary":"","tags":[],"title":"Welcome to SQL Components"},{"content":"","date":"0001-01-01","id":15,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":16,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"Hello Privacy\n","date":"0001-01-01","id":17,"permalink":"/privacy/","summary":"\u003cp\u003eHello Privacy\u003c/p\u003e","tags":[],"title":"Privacy Policy"},{"content":"","date":"0001-01-01","id":18,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]